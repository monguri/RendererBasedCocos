#include "3d/MGRSprite3D.h"
#include "3d/CCObjLoader.h"
#include "3d/CCMeshSkin.h"
#include "3d/CCBundle3D.h"
#include "3d/CCSprite3DMaterial.h"
#include "3d/CCAttachNode.h"
#include "3d/CCMesh.h"

#include "base/CCDirector.h"
#include "2d/CCLight.h"
#include "2d/CCCamera.h"
#include "base/ccMacros.h"
#include "platform/CCPlatformMacros.h"
#include "platform/CCFileUtils.h"
#include "renderer/CCTextureCache.h"
#include "renderer/CCRenderer.h"
#include "renderer/CCGLProgramState.h"
#include "renderer/CCGLProgramCache.h"
#include "renderer/CCMaterial.h"
#include "renderer/CCTechnique.h"
#include "renderer/CCPass.h"

#include "deprecated/CCString.h" // For StringUtils::format

NS_CC_BEGIN

static GLProgramState* getGLProgramStateForAttribs(MeshVertexData* meshVertexData, bool usesLight);

MGRSprite3D* MGRSprite3D::create()
{
    auto sprite = new (std::nothrow) MGRSprite3D();
    if (sprite && sprite->init())
    {
        sprite->autorelease();
        return sprite;
    }
    CC_SAFE_DELETE(sprite);
    return nullptr;
}

MGRSprite3D* MGRSprite3D::create(const std::string& modelPath)
{
    CCASSERT(modelPath.length() >= 4, "invalid filename for MGRSprite3D");

    auto sprite = new (std::nothrow) MGRSprite3D();
    if (sprite && sprite->initWithFile(modelPath))
    {
        sprite->_contentSize = sprite->getBoundingBox().size;
        sprite->autorelease();
        return sprite;
    }
    CC_SAFE_DELETE(sprite);
    return nullptr;
}

MGRSprite3D* MGRSprite3D::create(const std::string& modelPath, const std::string& texturePath)
{
    auto sprite = create(modelPath);
    if (sprite)
    {
        sprite->setTexture(texturePath); // textureって一枚で済むのか？
    }

    return sprite;
}

bool MGRSprite3D::loadFromFile(const std::string& path, NodeDatas* nodedatas, MeshDatas* meshdatas, MaterialDatas* materialdatas)
{
    // Bundle3Dのローダーを使ってc3bとかobjファイルからロードする。で、渡されたNodeDatasとMeshDatasとMaterialDatasに格納する

    std::string fullPath = FileUtils::getInstance()->fullPathForFilename(path);

    std::string ext = path.substr(path.length() - 4, 4);
    std::transform(ext.begin(), ext.end(), ext.begin(), tolower);
    if (ext == ".obj")
    {
        return Bundle3D::loadObj(*meshdatas, *materialdatas, *nodedatas, fullPath);
    }
    else if (ext == ".c3b" || ext == ".c3t")
    {
        // load from .c3b or .c3t
        auto bundle = Bundle3D::createBundle();
        if (!bundle->load(fullPath))
        {
            Bundle3D::destroyBundle(bundle);
            return false;
        }

        auto ret = bundle->loadMeshDatas(*meshdatas) && bundle->loadMaterials(*materialdatas) && bundle->loadNodes(*nodedatas);
        Bundle3D::destroyBundle(bundle);
        return ret;
    }

    return false;
}

MGRSprite3D::MGRSprite3D()
: _skeleton(nullptr)
, _blend(BlendFunc::ALPHA_NON_PREMULTIPLIED)
, _aabbDirty(true)
, _lightMask(-1)
, _shaderUsingLight(false)
, _forceDepthWrite(false)
, _usingAutogeneratedGLProgram(true)
{
}

MGRSprite3D::~MGRSprite3D()
{
    _meshes.clear();
    _meshVertexDatas.clear();
    CC_SAFE_RELEASE_NULL(_skeleton);
    removeAllAttachNode();
}

bool MGRSprite3D::init()
{
    if (Node::init())
    {
        return true;
    }

    return false;
}

bool MGRSprite3D::initWithFile(const std::string& path)
{
    // こいつらにデータを格納する。Vector<MeshVertexData>はバーテックスデータが主だが、Vector<MeshData>のMeshDataにはなんでも入ってる。マテリアルからテクスチャまで。
    _meshes.clear();
    _meshVertexDatas.clear();
    CC_SAFE_RELEASE_NULL(_skeleton);
    removeAllAttachNode();

    MeshDatas* meshdatas = new (std::nothrow) MeshDatas();
    MaterialDatas* materialdatas = new (std::nothrow) MaterialDatas();
    NodeDatas* nodedatas = new (std::nothrow) NodeDatas();

    if (loadFromFile(path, nodedatas, meshdatas, materialdatas))
    {
        if (initFrom(*nodedatas, *meshdatas, *materialdatas)) // この中でnodedatas、meshdatas、materialdatasから_meshes、_skelton、_meshVertexDatasにデータを移していく
        {
            CC_SAFE_DELETE(meshdatas);
            //CC_SAFE_DELETE(materialdatas);
            //CC_SAFE_DELETE(nodedatas);
            _contentSize = getBoundingBox().size;
            return true;
        }
    }

    CC_SAFE_DELETE(meshdatas);
    CC_SAFE_DELETE(materialdatas);
    CC_SAFE_DELETE(nodedatas);
    return false;
}

bool MGRSprite3D::initFrom(const NodeDatas& nodedatas, const MeshDatas& meshdatas, const MaterialDatas& materialdatas)
{
    for (const auto& it : meshdatas.meshDatas)
    {
        if (it)
        {
            auto meshvertex = MeshVertexData::create(*it);
            _meshVertexDatas.pushBack(meshvertex); // _meshVertexDatasはここで複数入る
        }
    }
    _skeleton = Skeleton3D::create(nodedatas.skeleton);
    CC_SAFE_RETAIN(_skeleton);

    // ここより下の意味がまだよくわからない。。なぜnodesがcreateNodeでskeltonがcreateAttachSprite3DNodeなんだ？
    for (const auto& it : nodedatas.nodes)
    {
        if (it)
        {
            createNode(it, this, materialdatas, nodedatas.nodes.size() == 1);
        }
    }
    for (const auto& it : nodedatas.skeleton)
    {
        if (it)
        {
            createAttachSprite3DNode(it, materialdatas);
        }
    }
    genGLProgramState();

    return true;
}

MGRSprite3D* MGRSprite3D::createSprite3DNode(NodeData* nodedata, ModelData* modeldata, const MaterialDatas& materialdatas)
{
    auto sprite = new (std::nothrow) MGRSprite3D();
    if (sprite)
    {
        sprite->setName(nodedata->id);
        auto mesh = Mesh::create(nodedata->id, getMeshIndexData(modeldata->subMeshId));
        if (modeldata->matrialId == "" && materialdatas.materials.size())
        {
            // この分岐の」条件なんなんだ？コメントくらいいれろや
            const NTextureData* textureData = materialdatas.materials[0].getTextureData(NTextureData::Usage::Diffuse);
            mesh->setTexture(textureData->filename);
        }
        else
        {
            const NMaterialData* materialData = materialdatas.getMaterialData(modeldata->matrialId);
            if (materialData)
            {
                const NTextureData* textureData = materialData->getTextureData(NTextureData::Usage::Diffuse);
                if (textureData)
                {
                    mesh->setTexture(textureData->filename); // meshってテクスチャのデータが必要なのか？
                    auto tex = mesh->getTexture();
                    if (tex)
                    {
                        Texture2D::TexParams texParams;
                        texParams.minFilter = GL_LINEAR;
                        texParams.magFilter = GL_LINEAR;
                        texParams.wrapS = textureData->wrapS;
                        texParams.wrapT = textureData->wrapT;
                        tex->setTexParameters(texParams);
                        mesh->_isTransparent = (materialData->getTextureData(NTextureData::Usage::Transparency) != nullptr);
                    }
                }
            }
        }

        // set locale transform
        Vec3 pos;
        Quaternion qua;
        Vec3 scale;
        nodedata->transform.decompose(&scale, &qua, &pos);
        sprite->setPosition3D(pos);
        sprite->setRotationQuat(qua);
        sprite->setScaleX(scale.x);
        sprite->setScaleY(scale.y);
        sprite->setScaleZ(scale.z);
        sprite->addMesh(mesh); //なんか、_meshsっていっても、ここで追加してる一個だけな気がするんだが。。。
        sprite->autorelease();
        sprite->genGLProgramState();
    }

    return sprite;
}

void MGRSprite3D::createAttachSprite3DNode(NodeData* nodedata, const MaterialDatas& materialdatas)
{
    for (const auto& it : nodedata->modelNodeDatas)
    {
        if (it && getAttachNode(nodedata->id))
        {
            auto sprite = createSprite3DNode(nodedata, it, materialdatas);
            if (sprite)
            {
                // Sprite3DNode同士がAttachNodeで接続される形
                getAttachNode(nodedata->id)->addChild(sprite);
            }
        }
    }

    for (const auto& it : nodedata->children) // modelNodeDatasとchildrenの違いってなんや。。：。
    {
        createAttachSprite3DNode(it, materialdatas);
    }
}

void MGRSprite3D::setMaterial(Material* material)
{
    setMaterial(material, -1);
}

void MGRSprite3D::setMaterial(Material* material, int meshIndex)
{
    CCASSERT(material, "Invalid Material");
    CCASSERT(meshIndex == -1 || (meshIndex >= 0 && meshIndex < _meshes.size()), "Invalid meshIndex");

    if (meshIndex == -1)
    {
        for (auto mesh : _meshes)
        {
            mesh->setMaterial(material); // テクスチャだけじゃなくマテリアルもメッシュに設定するんやね
        }
    }
    else
    {
        auto mesh = _meshes.at(meshIndex);
        mesh->setMaterial(material);
    }

    _usingAutogeneratedGLProgram = false;
}

Material* MGRSprite3D::getMaterial(int meshIndex) const
{
    CCASSERT(meshIndex >= 0 && meshIndex < _meshes.size(), "Invalid meshIndex");
    return _meshes.at(meshIndex)->getMaterial(); // やはりテクスチャもマテリアルもメッシュに入れる前提なんだね
}

void MGRSprite3D::genGLProgramState(bool useLight)
{
    _shaderUsingLight = useLight;


    // MeshVertexDataにGLProgramState作るための情報入ってるからそこから作って、対応するメッシュデータにのせるんやね。
    // 結局いろいろデータあるけど最終的にはメッシュデータにすべて集めるのね

    std::unordered_map<const MeshVertexData*, GLProgramState*> glProgramstates; // MeshVertexDataごとにGLProgramStateもつんやね
    for (auto meshVertexData : _meshVertexDatas)
    {
        auto glprogramstate = getGLProgramStateForAttribs(meshVertexData, useLight);
        glProgramstates[meshVertexData] = glprogramstate;
    }

    for (auto& mesh : _meshes)
    {
        auto glProgramState = glProgramstates[mesh->getMeshIndexData()->getMeshVertexData()];

        // hack to prevent cloning the very first time
        if (glProgramState->getReferenceCount() == 1)
        {
            mesh->setGLProgramState(glProgramState);
        }
        else
        {
            mesh->setGLProgramState(glProgramState->clone());
        }
    }
}

void MGRSprite3D::createNode(NodeData* nodedata, Node* root, const MaterialDatas& materialdatas, bool singleSprite)
{
    Node* node = nullptr;
    for (const auto& it : nodedata->modelNodeDatas)
    {
        // nullptrチェックは階層増やさずにやろうよ。。。
        if (it)
        {
            // singleSpriteだったらどう変わるかよくわかってない
            if (it->bones.size() > 0 || singleSprite)
            {
                if (singleSprite && root != nullptr)
                {
                    root->setName(nodedata->id);
                }

                auto mesh = Mesh::create(nodedata->id, getMeshIndexData(it->subMeshId));
                if (mesh)
                {
                    _meshes.pushBack(mesh); // createSprite3DNodeと異なり、ここで複数くっつける
                    if (_skeleton && it->bones.size())
                    {
                        auto skin = MeshSkin::create(_skeleton, it->bones, it->invBindPose);
                        mesh->setSkin(skin);
                    }
                    mesh->_visibleChanged = std::bind(&MGRSprite3D::onAABBDirty, this);

                    if (it->matrialId == "" && materialdatas.materials.size())
                    {
                        const NTextureData* textureData = materialdatas.materials[0].getTextureData(NTextureData::Usage::Diffuse);
                        // ここはtextureDataのnullptrチェックいらんのか？
                        mesh->setTexture(textureData->filename);
                    }
                    else
                    {
                        const NMaterialData* materialData = materialdatas.getMaterialData(it->matrialId);
                        if (materialData)
                        {
                            const NTextureData* textureData = materialData->getTextureData(NTextureData::Usage::Diffuse);
                            if (textureData)
                            {
                                mesh->setTexture(textureData->filename);
                                auto tex = mesh->getTexture();
                                if (tex)
                                {
                                    Texture2D::TexParams texParams;
                                    texParams.minFilter = GL_LINEAR;
                                    texParams.magFilter = GL_LINEAR;
                                    texParams.wrapS = textureData->wrapS;
                                    texParams.wrapT = textureData->wrapT;
                                    tex->setTexParameters(texParams);
                                    mesh->_isTransparent = (materialData->getTextureData(NTextureData::Usage::Transparency) != nullptr);
                                }
                            }
                        }
                    }

                    Vec3 pos;
                    Quaternion qua;
                    Vec3 scale;
                    nodedata->transform.decompose(&scale, &qua, &pos);
                    setPosition3D(pos);
                    setRotationQuat(qua);
                    setScaleX(scale.x);
                    setScaleY(scale.y);
                    setScaleZ(scale.z);
                }
            }
            else
            {
                // なぜsingleじゃなかったらcreateSprite3DNodeなのか？
                auto sprite = createSprite3DNode(nodedata, it, materialdatas);
                if (sprite)
                {
                    if (root)
                    {
                        root->addChild(sprite);
                    }
                }
                node = sprite;
            }
        }
    }

    if (nodedata->modelNodeDatas.size() == 0)
    {
        node = Node::create();
        if (node)
        {
            node->setName(nodedata->id);
            Vec3 pos;
            Quaternion qua;
            Vec3 scale;
            // modelNodeDatasのサイズが0なのにtransform情報はあるのか？
            nodedata->transform.decompose(&scale, &qua, &pos);
            node->setPosition3D(pos);
            node->setRotationQuat(qua);
            node->setScaleX(scale.x);
            node->setScaleY(scale.y);
            node->setScaleZ(scale.z);

            if (root)
            {
                root->addChild(node);
            }
        }
    }

    for (const auto& it : nodedata->children)
    {
        // 再帰
        createNode(it, node, materialdatas, nodedata->children.size() == 1);
    }
}

MeshIndexData* MGRSprite3D::getMeshIndexData(const std::string& indexId) const
{
    for (auto it : _meshVertexDatas)
    {
        auto index = it->getMeshIndexDataById(indexId);
        if (index)
        {
            return index;
        }
    }

    return nullptr;
}

void MGRSprite3D::addMesh(Mesh* mesh)
{
    auto meshVertex = mesh->getMeshIndexData()->_vertexData;
    _meshVertexDatas.pushBack(meshVertex);
    _meshes.pushBack(mesh);
}

void MGRSprite3D::setTexture(const std::string& texFile)
{
    auto tex = Director::getInstance()->getTextureCache()->addImage(texFile);
    setTexture(tex);
}

void MGRSprite3D::setTexture(Texture2D* texture)
{
    // MGRSprite3Dにメッシュは複数になる可能性はあるが、テクスチャは一枚だけしかセットはできない
    for (auto mesh : _meshes)
    {
        mesh->setTexture(texture);
    }
}

AttachNode* MGRSprite3D::getAttachNode(const std::string& boneName)
{
    // AttachNodeとはボーンの情報だけをもつ、接続部専用のノード
    auto it = _attachments.find(boneName);
    if (it != _attachments.end())
    {
        return it->second;
    }

    // _skelton情報はAttachNodeのためにある
    if (_skeleton)
    {
        auto bone = _skeleton->getBoneByName(boneName);
        if (bone)
        {
            // getといいつつ生成して返す。ならcreateにしようよ。。まあ_attachmentsにあれば」そっち返すもんな
            auto attachNode = AttachNode::create(bone);
            addChild(attachNode);
            _attachments[boneName] = attachNode;
            return attachNode;
        }
    }

    return nullptr;
}

void MGRSprite3D::removeAttachNode(const std::string& boneName)
{
    auto it = _attachments.find(boneName);
    if (it != _attachments.end())
    {
        removeChild(it->second);
        _attachments.erase(it);
    }
}

void MGRSprite3D::removeAllAttachNode()
{
    for (auto& it : _attachments)
    {
        removeChild(it.second);
    }
    _attachments.clear();
}

// ついについに描画系か。。。
void MGRSprite3D::visit(cocos2d::Renderer* renderer, const cocos2d::Mat4& parentTransform, uint32_t parentFlags)
{
    // quick return if not visible. children won't be drawn.
    if (!_visible)
    {
        return;
    }

    uint32_t flags = processParentFlags(parentTransform, parentFlags);
    flags |= FLAGS_RENDER_AS_3D;

    // これって何やってるんだ？
    Director* director = Director::getInstance();
    director->pushMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
    director->loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW, _modelViewTransform);

    bool visibleByCamera = isVisitableByVisitingCamera();

    int i = 0;

    if (!_children.empty())
    {
        sortAllChildren();
        // draw children zOrder < 0
        for (; i < _children.size(); i++)
        {
            auto node = _children.at(i);
            if (node && node->getLocalZOrder() < 0)
            {
                node->visit(renderer, _modelViewTransform, flags);
            }
            else
            {
                break;
            }
        }

        // self draw
        if (visibleByCamera)
        {
            draw(renderer, _modelViewTransform, flags);
        }

        for (auto it = _children.cbegin() + i; it != _children.cend(); ++it)
        {
            (*it)->visit(renderer, _modelViewTransform, flags);
        }
    }
    else if (visibleByCamera)
    {
        draw(renderer, _modelViewTransform, flags);
    }

    director->popMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
}

// お、drawはRenderer便りにしないんだ。でもそれだとvisit順に描画しちゃうけど、zバッファは使わないのか？sortAllChildrenのソート順はせいぜいzIndex順だぞ
// zバッファはGPUが勝手に考慮してくれるからOKなんだっけ？

void MGRSprite3D::draw(Renderer* renderer, const Mat4& transform, uint32_t flags)
{
#if CC_USE_CULLING
    // camera clipping
    if (Camera::getVisitingCamera() && !Camera::getVisitingCamera()->isVisibleInFrustum(&getAABB()))
    {
        return;
    }
#endif

    if (_skeleton)
    {
        _skeleton->updateBoneMatrix();
    }

    Color4F color(getDisplayedColor());
    color.a = getDisplayedOpacity() / 255.0f;

    const auto& scene = Director::getInstance()->getRunningScene();

    if (_usingAutogeneratedGLProgram && scene)
    {
        // ライトのことはよくわからんな。。
        const auto lights = scene->getLights();
        bool usingLight = false;
        for (const auto light : lights)
        {
            usingLight = ((unsigned int)light->getLightFlag() & _lightMask) > 0;
            if (usingLight)
            {
                break;
            }
        }
        if (usingLight != _shaderUsingLight)
        {
            genGLProgramState(usingLight);
        }
    }

    for (auto mesh : _meshes)
    {
        mesh->draw(renderer,
                    _globalZOrder,
                    _transform,
                    flags,
                    _lightMask,
                    Vec4(color.r, color.g, color.b, color.a),
                    _forceDepthWrite);
    }
}

// GLProgramStateとGLProgramの使い分けがわからん。。。
void MGRSprite3D::setGLProgramState(GLProgramState* glProgramState)
{
    Node::setGLProgramState(glProgramState);
    for (auto state : _meshes)
    {
        state->setGLProgramState(glProgramState);
    }
}

void MGRSprite3D::setGLProgram(GLProgram* glProgram)
{
    auto glProgramState = GLProgramState::create(glProgram);
    setGLProgramState(glProgramState);
}

void MGRSprite3D::setBlendFunc(const BlendFunc& blendFunc)
{
    if (_blend.src != blendFunc.src || _blend.dst != blendFunc.dst)
    {
        _blend = blendFunc;
        // blendFuncもMeshごと
        for (auto mesh : _meshes)
        {
            mesh->setBlendFunc(blendFunc);
        }
    }
}

const BlendFunc& MGRSprite3D::getBlendFunc() const
{
    return _blend;
}

AABB MGRSprite3D::getAABBRecursively()
{
    AABB aabb;
    const auto children = getChildren();
    for (const auto iter : children)
    {
        MGRSprite3D* child = dynamic_cast<MGRSprite3D*>(iter);
        if (child)
        {
            // このマージしなきゃいけないのは結構重い処理だな。。。
            aabb.merge(child->getAABBRecursively());
        }
    }

    aabb.merge(getAABB());
    return aabb;
}

const AABB& MGRSprite3D::getAABB() const
{
    // Recursivelyでないと子供までは見ないらしい。でもMGRSprite3Dって平気で子供作ってるよね。。
    Mat4 nodeToWorldTransform(getNodeToWorldTransform());

    // If nodeToWorldTransform matrix isn't changed, we don't need to transform aabb.
    // changeするきっかけって何があるの？
    if (memcmp(_nodeToWorldTransform.m, nodeToWorldTransform.m, sizeof(Mat4)) == 0 && !_aabbDirty)
    {
        return _aabb;
    }
    else
    {
        _aabb.reset();
        if (_meshes.size())
        {
            Mat4 transform(nodeToWorldTransform);
            for (const auto& it : _meshes)
            {
                if (it->isVisible())
                {
                    _aabb.merge(it->getAABB());
                }
            }

            _aabb.transform(transform);
            _nodeToWorldTransform = nodeToWorldTransform;
            _aabbDirty = false;
        }
    }

    return _aabb;
}

Action* MGRSprite3D::runAction(Action* action)
{
    setForceDepthWrite(true); //ここがNodeのrunActionと違うのね。でもなぜこれが必要？
    return Node::runAction(action);
}

Rect MGRSprite3D::getBoundingBox() const
{
    AABB aabb = getAABB();
    Rect ret(aabb._min.x, aabb._min.y, (aabb._max.x - aabb._min.x), (aabb._max.y - aabb._min.y));
    return ret;
}

void MGRSprite3D::setCullFace(GLenum cullFace)
{
    // GL_FRONTとかGL_BACKとかどっちの面を表示するかを指定する
    // カリング面もメッシュごとなのね
    for (auto& it : _meshes)
    {
        // StateBlockってなんやろ
        it->getMaterial()->getStateBlock()->setCullFaceSide((RenderState::CullFaceSide)cullFace);
    }
}

void MGRSprite3D::setCullFaceEnabled(bool enable)
{
    for (auto& it : _meshes)
    {
        it->getMaterial()->getStateBlock()->setCullFace(enable);

    }
}

Mesh* MGRSprite3D::getMeshByIndex(int index) const
{
    CCASSERT(index < _meshes.size(), "invalid index");
    return _meshes.at(index);
}

Mesh* MGRSprite3D::getMeshByName(const std::string& name) const
{
    for (const auto& it : _meshes)
    {
        if (it->getName() == name)
        {
            return it;
        }
    }

    return nullptr;
}

std::vector<Mesh*> MGRSprite3D::getMeshArrayByName(const std::string& name) const
{
    // え、同じ名前のメッシュが複数ありうるの？　まあそういう風にfbx作っちゃうとあるんだろうけど
    std::vector<Mesh*> meshes;
    for (const auto& it : _meshes)
    {
        if (it->getName() == name)
        {
            meshes.push_back(it);
        }
    }

    return meshes;
}

MeshSkin* MGRSprite3D::getSkin() const
{
    for (const auto& it : _meshes)
    {
        // え？最初にみつけたスキンを返すの？
        if (it->getSkin())
        {
            return it->getSkin();
        }
    }

    return nullptr;
}

void MGRSprite3D::setForce2DQueue(bool force2D)
{
    for (const auto& mesh : _meshes)
    {
        mesh->setForce2DQueue(force2D);
    }
}

//
// MARK: Helpers
//
static GLProgramState* getGLProgramStateForAttribs(MeshVertexData* meshVertexData, bool usesLight)
{
    bool textured = meshVertexData->hasVertexAttrib(GLProgram::VERTEX_ATTRIB_TEX_COORD);
    // なぜブレンドインデックスがあるとスキン持ってることになるんだ？
    bool hasSkin = meshVertexData->hasVertexAttrib(GLProgram::VERTEX_ATTRIB_BLEND_INDEX)
        && meshVertexData->hasVertexAttrib(GLProgram::VERTEX_ATTRIB_BLEND_WEIGHT);
    bool hasNormal = meshVertexData->hasVertexAttrib(GLProgram::VERTEX_ATTRIB_NORMAL);

    const char* shader = nullptr;
    if (textured)
    {
        if (hasSkin)
        {
            if (hasNormal && usesLight)
            {
                shader = GLProgram::SHADER_3D_SKINPOSITION_NORMAL_TEXTURE;
            }
            else
            {
                shader = GLProgram::SHADER_3D_SKINPOSITION_TEXTURE;
            }
        }
        else
        {
            if (hasNormal && usesLight)
            {
                shader = GLProgram::SHADER_3D_POSITION_NORMAL_TEXTURE;
            }
            else
            {
                shader = GLProgram::SHADER_3D_POSITION_TEXTURE;
            }
        }
    }
    else
    {
        if (hasNormal && usesLight)
        {
            shader = GLProgram::SHADER_3D_POSITION_NORMAL;
        }
        else
        {
            shader = GLProgram::SHADER_3D_POSITION;
        }
    }

    CCASSERT(shader, "Couldn't find shader for sprite");
    auto glProgram = GLProgramCache::getInstance()->getGLProgram(shader); // GLProgramってシェーダから一意に決まるんだ
    auto glprogramstate = GLProgramState::create(glProgram); // GLProgramStateもシェーダから一意に決まるんだ

    return glprogramstate;
}

NS_CC_END
